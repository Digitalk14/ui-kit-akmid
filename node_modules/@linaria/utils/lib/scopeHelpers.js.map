{"version":3,"file":"scopeHelpers.js","names":["getBinding","path","binding","scope","node","name","undefined","reference","referencePath","force","isReferencedIdentifier","referencePaths","includes","referenced","references","push","isReferenced","kind","some","i","find","ancestor","isTSType","isFlowType","dereference","filter","length","dereferenceAll","findIdentifiers","map","identifierPath","isNotNull","referenceAll","forEach","deletingNodes","WeakSet","findParentForDelete","isRemoved","add","parent","parentPath","isProgram","isLogicalExpression","operator","mutate","p","replaceWith","type","value","isObjectProperty","key","get","isIdentifier","maybeDefineProperty","isCallExpression","matchesPattern","isTemplateLiteral","isAssignmentExpression","isForInStatement","left","isFunctionExpression","body","isFunctionDeclaration","isObjectMethod","isClassMethod","isBlockStatement","listKey","prevStatement","isIfStatement","isReturnStatement","slice","every","statement","has","isVariableDeclarator","isExportNamedDeclaration","specifiers","declaration","isExportDefaultDeclaration","isTryStatement","isExportSpecifier","isConditionalExpression","list","referenceEnums","program","traverse","ExpressionStatement","expressionStatement","expression","callee","args","arg","fixed","removeUnreferenced","items","Set","item","hasReferences","forDeleting","constantViolations","identifier","removeWithRelated","result","sort","a","b","localeCompare","paths","rootPath","getProgramParent","clean","referencedIdentifiers","declared","deletingPath","remove","reduce","acc","nonType","join","fn","dereferenced","mutated","dead","assignments","assignment","Object","values","getOuterBindingIdentifiers","Identifier","isArrayPattern","elements"],"sources":["../src/scopeHelpers.ts"],"sourcesContent":["/* eslint-disable no-restricted-syntax */\n/* eslint @typescript-eslint/no-use-before-define: [\"error\", { \"functions\": false }] */\n\nimport type { Binding, NodePath } from '@babel/traverse';\nimport type { Identifier, JSXIdentifier, Program } from '@babel/types';\n\nimport findIdentifiers, { nonType } from './findIdentifiers';\nimport isNotNull from './isNotNull';\nimport isRemoved from './isRemoved';\n\nfunction getBinding(path: NodePath<Identifier | JSXIdentifier>) {\n  const binding = path.scope.getBinding(path.node.name);\n  if (!binding) {\n    return undefined;\n  }\n\n  return binding;\n}\n\nexport function reference(\n  path: NodePath<Identifier | JSXIdentifier>,\n  referencePath: NodePath = path,\n  force = false\n): void {\n  if (!force && !path.isReferencedIdentifier()) return;\n\n  const binding = getBinding(path);\n  if (!binding) return;\n\n  if (binding.referencePaths.includes(referencePath)) {\n    return;\n  }\n\n  binding.referenced = true;\n  binding.references += 1;\n  binding.referencePaths.push(referencePath ?? path);\n}\n\nfunction isReferenced(binding: Binding) {\n  if (!binding.referenced) {\n    return false;\n  }\n\n  // If it's a param binding, we can't just remove it\n  // because it brakes the function signature. Keep it alive for now.\n  if ((binding.kind as string) === 'param') {\n    return true;\n  }\n\n  // If all remaining references are in TS/Flow types, binding is unreferenced\n  return binding.referencePaths.some(\n    (i) => !i.find((ancestor) => ancestor.isTSType() || ancestor.isFlowType())\n  );\n}\n\nexport function dereference(\n  path: NodePath<Identifier | JSXIdentifier>\n): Binding | null {\n  const binding = getBinding(path);\n  if (!binding) return null;\n\n  if (!binding.referencePaths.includes(path)) {\n    return null;\n  }\n\n  binding.references -= 1;\n  binding.referencePaths = binding.referencePaths.filter((i) => i !== path);\n  binding.referenced = binding.referencePaths.length > 0;\n\n  return binding;\n}\n\nfunction dereferenceAll(path: NodePath): Binding[] {\n  return findIdentifiers([path])\n    .map((identifierPath) => dereference(identifierPath))\n    .filter(isNotNull);\n}\n\nexport function referenceAll(path: NodePath): void {\n  findIdentifiers([path]).forEach((identifierPath) =>\n    reference(identifierPath)\n  );\n}\n\nconst deletingNodes = new WeakSet<NodePath>();\n\nexport function findParentForDelete(path: NodePath): NodePath | null {\n  if (isRemoved(path)) return null;\n\n  deletingNodes.add(path);\n\n  const parent = path.parentPath;\n\n  if (!parent) return path;\n\n  if (parent.isProgram()) {\n    // Do not delete Program node\n    return path;\n  }\n\n  if (parent.isLogicalExpression({ operator: '&&' })) {\n    mutate(parent, (p) => {\n      p.replaceWith({\n        type: 'BooleanLiteral',\n        value: false,\n      });\n    });\n\n    return null;\n  }\n\n  if (parent.isObjectProperty()) {\n    // let's check if it is a special case with Object.defineProperty\n    const key = parent.get('key');\n    if (key.isIdentifier({ name: 'get' })) {\n      const maybeDefineProperty = parent.parentPath.parentPath;\n      if (\n        maybeDefineProperty?.isCallExpression() &&\n        maybeDefineProperty\n          .get('callee')\n          .matchesPattern('Object.defineProperty')\n      ) {\n        return findParentForDelete(maybeDefineProperty);\n      }\n    }\n\n    return findParentForDelete(parent);\n  }\n\n  if (parent.isTemplateLiteral()) {\n    mutate(path, (p) => {\n      p.replaceWith({\n        type: 'StringLiteral',\n        value: '',\n      });\n    });\n    return null;\n  }\n\n  if (parent.isAssignmentExpression()) {\n    return findParentForDelete(parent);\n  }\n\n  if (parent.isCallExpression()) {\n    return findParentForDelete(parent);\n  }\n\n  if (parent.isForInStatement({ left: path.node })) {\n    return findParentForDelete(parent);\n  }\n\n  if (\n    parent.isFunctionExpression({ body: path.node }) ||\n    parent.isFunctionDeclaration() ||\n    parent.isObjectMethod() ||\n    parent.isClassMethod()\n  ) {\n    return findParentForDelete(parent);\n  }\n\n  if (parent.isBlockStatement()) {\n    const body = parent.get('body');\n    if (body.length === 1) {\n      return findParentForDelete(parent);\n    }\n\n    if (path.listKey === 'body' && typeof path.key === 'number') {\n      if (path.key > 0) {\n        // We can check whether the previous one can be removed\n        const prevStatement = body[path.key - 1];\n        if (\n          prevStatement.isIfStatement() &&\n          prevStatement.get('consequent').isReturnStatement()\n        ) {\n          // It's `if (…) return …`, we can remove it.\n          return findParentForDelete(prevStatement);\n        }\n      } else if (\n        body.slice(1).every((statement) => deletingNodes.has(statement))\n      ) {\n        // If it is the first statement and all other statements\n        // are marked for deletion, we can remove the whole block.\n        return findParentForDelete(parent);\n      }\n    }\n  }\n\n  if (parent.isVariableDeclarator()) {\n    return findParentForDelete(parent);\n  }\n\n  if (\n    parent.isExportNamedDeclaration() &&\n    ((parent.node.specifiers.length === 1 &&\n      parent.node.specifiers[0] === path.node) ||\n      parent.node.declaration === path.node)\n  ) {\n    return findParentForDelete(parent);\n  }\n\n  if (parent.isExportDefaultDeclaration()) {\n    return findParentForDelete(parent);\n  }\n\n  if (parent.isTryStatement()) {\n    return findParentForDelete(parent);\n  }\n\n  if (parent.isExportSpecifier()) {\n    return findParentForDelete(parent);\n  }\n\n  if (parent.isConditionalExpression()) {\n    return findParentForDelete(parent);\n  }\n\n  for (const key of ['body', 'declarations', 'specifiers']) {\n    if (path.listKey === key && typeof path.key === 'number') {\n      const list = parent.get(key) as NodePath[];\n      if (list.length === 1) {\n        return findParentForDelete(parent);\n      }\n    }\n  }\n\n  for (const key of [\n    'argument',\n    'block',\n    'body',\n    'callee',\n    'discriminant',\n    'expression',\n    'id',\n    'left',\n    'object',\n    'property',\n    'right',\n    'test',\n  ]) {\n    if (path.key === key && parent.get(key) === path) {\n      return findParentForDelete(parent);\n    }\n  }\n\n  return path;\n}\n\n// @babel/preset-typescript transpiles enums, but doesn't reference used identifiers.\nfunction referenceEnums(program: NodePath<Program>) {\n  /*\n   * We are looking for transpiled enums.\n   *   (function (Colors) {\n   *     Colors[\"BLUE\"] = \"#27509A\";\n   *   })(Colors || (Colors = {}));\n   */\n  program.traverse({\n    ExpressionStatement(expressionStatement) {\n      const expression = expressionStatement.get('expression');\n      if (!expression.isCallExpression()) return;\n\n      const callee = expression.get('callee');\n      const args = expression.get('arguments');\n      if (!callee.isFunctionExpression() || args.length !== 1) return;\n      const [arg] = args;\n      if (arg.isLogicalExpression({ operator: '||' })) {\n        referenceAll(arg);\n      }\n    },\n  });\n}\n\nconst fixed = new WeakSet<NodePath<Program>>();\n\nfunction removeUnreferenced(items: NodePath<Identifier | JSXIdentifier>[]) {\n  const referenced = new Set<NodePath<Identifier | JSXIdentifier>>();\n  items.forEach((item) => {\n    if (!item.node || isRemoved(item)) return;\n    const binding = item.scope.getBinding(item.node.name);\n    if (!binding) return;\n    const hasReferences =\n      binding.referencePaths.filter((i) => !isRemoved(i)).length > 0;\n    if (hasReferences) {\n      referenced.add(item);\n      return;\n    }\n\n    const forDeleting = [binding.path, ...binding.constantViolations]\n      .map((i) => findParentForDelete(i))\n      .filter(isNotNull);\n\n    if (forDeleting.length === 0) return;\n\n    findIdentifiers(forDeleting).forEach((identifier) => {\n      referenced.add(identifier);\n    });\n\n    removeWithRelated(forDeleting);\n  });\n\n  const result = [...referenced];\n  result.sort((a, b) => a.node?.name.localeCompare(b.node?.name));\n\n  return result;\n}\n\nfunction removeWithRelated(paths: NodePath[]) {\n  if (paths.length === 0) return;\n\n  const rootPath = paths[0].scope.getProgramParent().path as NodePath<Program>;\n\n  if (!fixed.has(rootPath)) {\n    // Some libraries don't care about bindings, references, and other staff\n    // So we have to fix the scope before we can detect unused code\n    referenceEnums(rootPath);\n    fixed.add(rootPath);\n  }\n\n  let clean = false;\n  let referencedIdentifiers: NodePath<Identifier | JSXIdentifier>[] = [];\n  const declared: Binding[] = [];\n\n  paths.forEach((path) => {\n    const deletingPath = findParentForDelete(path);\n    if (!deletingPath) return;\n\n    referencedIdentifiers.push(\n      ...findIdentifiers([deletingPath], 'referenced')\n    );\n    declared.push(\n      ...findIdentifiers([deletingPath], 'binding').map(\n        (i) => i.scope.getBinding(i.node.name)!\n      )\n    );\n\n    mutate(deletingPath, (p) => {\n      if (!isRemoved(p)) p.remove();\n    });\n  });\n\n  if (declared.length > 0) {\n    removeWithRelated(\n      declared.reduce(\n        (acc, i) => [...acc, ...i.referencePaths.filter(nonType)],\n        [] as NodePath[]\n      )\n    );\n  }\n\n  referencedIdentifiers.sort((a, b) =>\n    a.node?.name.localeCompare(b.node?.name)\n  );\n\n  while (!clean && referencedIdentifiers.length > 0) {\n    const referenced = removeUnreferenced(referencedIdentifiers);\n    clean =\n      referenced.map((i) => i.node?.name).join('|') ===\n      referencedIdentifiers.map((i) => i.node?.name).join('|');\n    referencedIdentifiers = referenced;\n  }\n}\n\nfunction mutate<T extends NodePath>(path: T, fn: (p: T) => NodePath[] | void) {\n  const dereferenced = dereferenceAll(path);\n\n  const mutated = fn(path);\n\n  referenceAll(path);\n  mutated?.forEach((p) => referenceAll(p));\n\n  const dead = dereferenced.filter((p) => !isReferenced(p));\n\n  const forDeleting: NodePath[] = [];\n  dead.forEach((binding) => {\n    const assignments = [binding.path, ...binding.constantViolations];\n    assignments.forEach((assignment) => {\n      const { scope } = assignment;\n      const declared = Object.values(\n        assignment.getOuterBindingIdentifiers(false)\n      );\n      if (\n        declared.length === 1 &&\n        'name' in declared[0] &&\n        declared[0].name === binding.identifier.name\n      ) {\n        // Only one identifier is declared, so we can remove the whole declaration\n        forDeleting.push(assignment);\n        return;\n      }\n\n      if (\n        declared.every(\n          (identifier) =>\n            identifier.type === 'Identifier' &&\n            !scope.getBinding(identifier.name)?.referenced\n        )\n      ) {\n        // No other identifier is referenced, so we can remove the whole declaration\n        forDeleting.push(assignment);\n        return;\n      }\n\n      // We can't remove the binding, but we can remove the part of it\n      assignment.traverse({\n        Identifier(identifier) {\n          if (identifier.node.name === binding.identifier.name) {\n            const parent = identifier.parentPath;\n            if (\n              parent.isArrayPattern() &&\n              identifier.listKey === 'elements' &&\n              typeof identifier.key === 'number'\n            ) {\n              parent.node.elements[identifier.key] = null;\n            } else if (parent.isObjectProperty()) {\n              forDeleting.push(parent);\n            }\n          }\n        },\n      });\n    });\n  });\n\n  removeWithRelated(forDeleting);\n}\n\nexport { mutate, removeWithRelated };\n"],"mappings":"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"}